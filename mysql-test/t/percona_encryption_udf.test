--source include/have_udf.inc

#
# Creating functions from encryption_udf
#

SET @message = 'message';
SET @digest_type = 'SHA224';

--echo
--echo ** checking 'create_digest()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION create_digest RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

--error ER_CANT_INITIALIZE_UDF
SELECT create_digest();

--error ER_CANT_INITIALIZE_UDF
SELECT create_digest(@digest_type);

--error ER_UDF_ERROR
SELECT create_digest(@digest_type, NULL);

--error ER_UDF_ERROR
SELECT create_digest('FOO', @message);

--let $number_of_length_iterations = 16
--let $length_increment = 7
eval SET @random_pattern = REPEAT(MD5(42), $number_of_length_iterations * $length_increment DIV 32 + 1);

--echo ** checking digests calculation

CREATE TEMPORARY TABLE digest_type(
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  digest_name VARCHAR(64) NOT NULL,
  builtin_template VARCHAR(64),
  PRIMARY KEY(id)
);
INSERT INTO digest_type(digest_name, builtin_template) VALUES
  ('MD5' , 'MD5(@message)'),
  ('SHA1', 'SHA(@message)'),

  ('SHA224', 'SHA2(@message, 224)'),
  ('SHA256', 'SHA2(@message, 256)'),
  ('SHA384', 'SHA2(@message, 384)'),
  ('SHA512', 'SHA2(@message, 512)'),

  ('BLAKE2B512', NULL),
  ('BLAKE2S256', NULL),
  ('MD4'       , NULL),
  ('RIPEMD'    , NULL),
  ('RIPEMD160' , NULL),
  ('RMD160'    , NULL),
  ('SHAKE128'  , NULL),
  ('SHAKE256'  , NULL),
  ('SM3'       , NULL),
  ('WHIRLPOOL' , NULL)
;
--let $number_of_digest_types = `SELECT COUNT(*) FROM digest_type`

--disable_query_log
--let $digest_type_idx = 1
while($digest_type_idx <= $number_of_digest_types)
{
  --let $digest_name = `SELECT digest_name FROM digest_type WHERE id = $digest_type_idx`
  --let $udf_template = HEX(create_digest("$digest_name", @message))
  --echo **** [$digest_name] checking digest

  --let $builtin_template = `SELECT builtin_template FROM digest_type WHERE id = $digest_type_idx`
  --let $current_length_iteration = 0
  --let $number_of_length_iterations = 16
  while($current_length_iteration <= $number_of_length_iterations)
  {
    --let $message_length = `SELECT $current_length_iteration * $length_increment`
    --echo ****** [$digest_name][message_len=$message_length] checking digest calculation on message
    if($builtin_template)
    {
      --echo ******** [$digest_name][message_len=$message_length] checking if identical to built-in $builtin_template
    }
    eval SET @message = LEFT(@random_pattern, $message_length);

    if($builtin_template)
    {
      --let $assert_text = [$digest_name][message_len=$message_length] digest of a message calculated via UDF should match built-in function result
      --let $assert_cond = $udf_template = $builtin_template
    }
    if(!$builtin_template)
    {
      --let $assert_text = [$digest_name][message_len=$message_length] digest of a message calculated via UDF is not NULL
      --let $assert_cond = $udf_template IS NOT NULL
    }
    --let $include_silent = 1
    --source include/assert.inc
    --let $include_silent =

    --inc $current_length_iteration
  }

  --inc $digest_type_idx
}
--enable_query_log


SET @algorithm = 'RSA';
SET @message = 'message';


--echo
--echo ** checking 'create_asymmetric_priv_key()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION create_asymmetric_priv_key RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

--error ER_CANT_INITIALIZE_UDF
SELECT create_asymmetric_priv_key();

--error ER_CANT_INITIALIZE_UDF
SELECT create_asymmetric_priv_key(@algorithm);

--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key(@algorithm, NULL);
--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key(@algorithm, 0);
--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key(@algorithm, -1);
--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key(@algorithm, 'blah');

--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key('RSA', 1023);
--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key('DSA', 1023);

--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key('RSA', 16385);
--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key('DSA', 9985);


--echo
--echo ** checking 'create_asymmetric_pub_key()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION create_asymmetric_pub_key RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

--error ER_CANT_INITIALIZE_UDF
SELECT create_asymmetric_pub_key();

--error ER_CANT_INITIALIZE_UDF
SELECT create_asymmetric_pub_key(@algorithm);

--error ER_UDF_ERROR
SELECT create_asymmetric_pub_key(@algorithm, NULL);
--error ER_UDF_ERROR
SELECT create_asymmetric_pub_key(@algorithm, 42);
--error ER_UDF_ERROR
SELECT create_asymmetric_pub_key(@algorithm, 'blah-blah');

--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key('FOO', 2048);


--echo
--echo ** checking 'asymmetric_encrypt()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION asymmetric_encrypt RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_encrypt();

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_encrypt(@algorithm);

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_encrypt(@algorithm, @message);

--error ER_UDF_ERROR
SELECT asymmetric_encrypt(@algorithm, @message, NULL);
--error ER_UDF_ERROR
SELECT asymmetric_encrypt(@algorithm, @message, 42);
--error ER_UDF_ERROR
SELECT asymmetric_encrypt(@algorithm, @message, 'blah-blah');

--error ER_UDF_ERROR
SELECT asymmetric_encrypt(@algorithm, NULL, NULL);


--echo
--echo ** checking 'asymmetric_decrypt()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION asymmetric_decrypt RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_decrypt();

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_decrypt(@algorithm);

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_decrypt(@algorithm, @message);

--error ER_UDF_ERROR
SELECT asymmetric_decrypt(@algorithm, @message, NULL);
--error ER_UDF_ERROR
SELECT asymmetric_decrypt(@algorithm, @message, 42);
--error ER_UDF_ERROR
SELECT asymmetric_decrypt(@algorithm, @message, 'blah-blah');

--error ER_UDF_ERROR
SELECT asymmetric_decrypt(@algorithm, NULL, NULL);


--echo
--echo ** checking 'asymmetric_sign()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION asymmetric_sign RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

SET @message_digest = create_digest(@digest_type, @message);
SET @priv = create_asymmetric_priv_key(@algorithm, 1024);

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_sign();

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_sign(@algorithm);

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_sign(@algorithm, @message_digest);

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_sign(@algorithm, @message_digest, @priv);

--error ER_UDF_ERROR
SELECT asymmetric_sign(NULL, @message_digest, @priv, @digest_type);
--error ER_UDF_ERROR
SELECT asymmetric_sign(42, @message_digest, @priv, @digest_type);
--error ER_UDF_ERROR
SELECT asymmetric_sign('XSA', @message_digest, @priv, @digest_type);

--error ER_UDF_ERROR
SELECT asymmetric_sign(@algorithm, NULL, @priv, @digest_type);

--error ER_UDF_ERROR
SELECT asymmetric_sign(@algorithm, @message_digest, NULL, @digest_type);
--error ER_UDF_ERROR
SELECT asymmetric_sign(@algorithm, @message_digest, 42, @digest_type);
--error ER_UDF_ERROR
SELECT asymmetric_sign(@algorithm, @message_digest, 'blah-blah', @digest_type);

--error ER_UDF_ERROR
SELECT asymmetric_sign(@algorithm, @message_digest, @priv, NULL);
--error ER_UDF_ERROR
SELECT asymmetric_sign(@algorithm, @message_digest, @priv, 42);
--error ER_UDF_ERROR
SELECT asymmetric_sign(@algorithm, @message_digest, @priv, 'SHAX');


--echo
--echo ** checking 'asymmetric_verify()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION asymmetric_verify RETURNS INTEGER SONAME "$ENCRYPTION_UDF_LIB";

SET @signature = asymmetric_sign(@algorithm, @message_digest, @priv, @digest_type);
SET @pub = create_asymmetric_pub_key(@algorithm, @priv);

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_verify();

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_verify(@algorithm);

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_verify(@algorithm, @message_digest);

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_verify(@algorithm, @message_digest, @signature);

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_verify(@algorithm, @message_digest, @signature, @pub);

--error ER_UDF_ERROR
SELECT asymmetric_verify(NULL, @message_digest, @signature, @pub, @digest_type);
--error ER_UDF_ERROR
SELECT asymmetric_verify(42, @message_digest, @signature, @pub, @digest_type);
--error ER_UDF_ERROR
SELECT asymmetric_verify('XSA', @message_digest, @signature, @pub, @digest_type);

--error ER_UDF_ERROR
SELECT asymmetric_verify(@algorithm, NULL, @signature, @pub, @digest_type);

--error ER_UDF_ERROR
SELECT asymmetric_verify(@algorithm, @message_digest, NULL, @pub, @digest_type);

--error ER_UDF_ERROR
SELECT asymmetric_verify(@algorithm, @message_digest, @signature, NULL, @digest_type);
--error ER_UDF_ERROR
SELECT asymmetric_verify(@algorithm, @message_digest, @signature, 42, @digest_type);
--error ER_UDF_ERROR
SELECT asymmetric_verify(@algorithm, @message_digest, @signature, 'blah-blah', @digest_type);

--error ER_UDF_ERROR
SELECT asymmetric_verify(@algorithm, @message_digest, @signature, @pub, NULL);
--error ER_UDF_ERROR
SELECT asymmetric_verify(@algorithm, @message_digest, @signature, @pub, 42);
--error ER_UDF_ERROR
SELECT asymmetric_verify(@algorithm, @message_digest, @signature, @pub, 'SHAX');


--echo
--echo ** checking private key generation, public key derivation, encryption/decryption and sign/verify functionality
--let $algorithm_index = 1
--disable_query_log
while ($algorithm_index <= 2)
{
  --let $algorithm = `SELECT ELT($algorithm_index, 'RSA', 'DSA')`
  --echo
  --echo ** [$algorithm] checking asymmertic algorithm functions
  # DSA max key length must be <= 10000 and be a multiple of 64, therefore 9984
  --let $max_key_length = `SELECT ELT($algorithm_index, 16384, 9984)`
  eval SET @algorithm = "$algorithm";

  --let $key_length_index = 1
  while ($key_length_index <= 2)
  {
    --let $key_length = `SELECT ELT($key_length_index, 1024, 4096, $max_key_length)`
    --echo ** [$algorithm][$key_length] checking asymmetric algorithm functions
    --echo **** [$algorithm][$key_length] generating private key
    eval SET @priv = create_asymmetric_priv_key(@algorithm, $key_length);
    --echo **** [$algorithm][$key_length] deriving public key
    SET @pub = create_asymmetric_pub_key(@algorithm, @priv);

    # for RSA <max message size> = <key length in bytes> - <pkcs1 padding>
    --let $max_message_size = `SELECT $key_length DIV 8`
    if ($algorithm == 'RSA')
    {
      --let $max_message_size = `SELECT $max_message_size - 11`
    }

    # size of MD5 hash in bytes is 32
    eval SET @random_pattern = REPEAT(MD5(42), $max_message_size DIV 32 + 1);

    if ($algorithm == 'RSA')
    {
      --echo **** [$algorithm][$key_length] checking operations on NULL message
      SET @message = NULL;
      --echo ****** [$algorithm][$key_length] checking encryption with public key of NULL message
      --error ER_UDF_ERROR
      SELECT asymmetric_encrypt(@algorithm, @message, @pub);
      --echo ****** [$algorithm][$key_length] checking encryption with privcate key of NULL message
      --error ER_UDF_ERROR
      SELECT asymmetric_encrypt(@algorithm, @message, @priv);
    }

    --let $message_index = 1
    while ($message_index <= 4)
    {
      --let $message_length = `SELECT ELT($message_index, 0, 1, $max_message_size DIV 2, $max_message_size)`
      eval SET @message = LEFT(@random_pattern, $message_length);
      --echo **** [$algorithm][$key_length][message_len=$message_length] checking operations

      if ($algorithm == 'RSA')
      {
        --echo ****** [$algorithm][$key_length][message_len=$message_length] checking encryption with public key
        SET @message_enc_with_pub = asymmetric_encrypt(@algorithm, @message, @pub);
        --echo ****** [$algorithm][$key_length][message_len=$message_length] checking decryption with private key
        SET @message_dec_with_priv = asymmetric_decrypt(@algorithm, @message_enc_with_pub, @priv);
        --let $assert_text = [$algorithm][$key_length][message_len=$message_length] message decrypted with private key must match the original one
        --let $assert_cond = @message_dec_with_priv = @message
        --let $include_silent = 1
        --source include/assert.inc
        --let $include_silent =

        --echo ****** [$algorithm][$key_length][message_len=$message_length] checking encryption with private key
        SET @message_enc_with_priv = asymmetric_encrypt(@algorithm, @message, @priv);
        --echo ****** [$algorithm][$key_length][message_len=$message_length] checking decryption with public key
        SET @message_dec_with_pub = asymmetric_decrypt(@algorithm, @message_enc_with_priv, @pub);
        --let $assert_text = [$algorithm][$key_length][message_len=$message_length] message decrypted with public key must match the original one
        --let $assert_cond = @message_dec_with_pub = @message
        --let $include_silent = 1
        --source include/assert.inc
        --let $include_silent =
      }

      --echo ****** [$algorithm][$key_length][message_len=$message_length] checking sign/verify functionality
      --let $digest_type_idx = 1
      while($digest_type_idx <= $number_of_digest_types)
      {
        --let $digest_name = `SELECT digest_name FROM digest_type WHERE id = $digest_type_idx`
        --echo ******** [$algorithm][$key_length][message_len=$message_length][$digest_name] calculating digest
        eval SET @digest_type = '$digest_name';
        SET @message_digest = create_digest(@digest_type, @message);
        --echo ******** [$algorithm][$key_length][message_len=$message_length][$digest_name] calculating signature
        SET @message_signature = asymmetric_sign(@algorithm, @message_digest, @priv, @digest_type);
        --echo ******** [$algorithm][$key_length][message_len=$message_length][$digest_name] verifying signature
        SET @verification_result = asymmetric_verify(@algorithm, @message_digest, @message_signature, @pub, @digest_type);
        --let $assert_text = [$algorithm][$key_length][message_len=$message_length][$digest_name] signature must pass verification
        --let $assert_cond = @verification_result = 1
        --let $include_silent = 1
        --source include/assert.inc
        --let $include_silent =

        --inc $digest_type_idx
      }

      --inc $message_index
    }

    if ($algorithm == 'RSA')
    {
      --let $message_length = $max_message_size + 1
      --echo **** [$algorithm][$key_length] checking operations on oversize message
      eval SET @message = LEFT(@random_pattern, $message_length);
      --echo ****** [$algorithm][$key_length] checking encryption of oversize message with public key
      --error ER_UDF_ERROR
      SELECT asymmetric_encrypt(@algorithm, @message, @pub);
      --echo ****** [$algorithm][$key_length] checking encryption of oversize message with private key
      --error ER_UDF_ERROR
      SELECT asymmetric_encrypt(@algorithm, @message, @priv);
    }

    --inc $key_length_index
  }

  --inc $algorithm_index
}
--enable_query_log

--echo
--echo ** checking 'create_dh_parameters()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION create_dh_parameters RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

--error ER_CANT_INITIALIZE_UDF
SELECT create_dh_parameters();

--error ER_UDF_ERROR
SELECT create_dh_parameters(NULL);
--error ER_UDF_ERROR
SELECT create_dh_parameters(0);
--error ER_UDF_ERROR
SELECT create_dh_parameters(-1);
--error ER_UDF_ERROR
SELECT create_dh_parameters('blah');

--error ER_UDF_ERROR
SELECT create_dh_parameters(1023);

--error ER_UDF_ERROR
SELECT create_dh_parameters(10001);


SET @dh_params = create_dh_parameters(2048);

SET @dh_priv1 = create_asymmetric_priv_key('DH', @dh_params);
SET @dh_pub1 =  create_asymmetric_pub_key('DH', @dh_priv1);

SET @dh_priv2 = create_asymmetric_priv_key('DH', @dh_params);
SET @dh_pub2 =  create_asymmetric_pub_key('DH', @dh_priv2);


--echo
--echo ** checking 'asymmetric_derive()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION asymmetric_derive RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_derive();

--error ER_UDF_ERROR
SELECT asymmetric_derive(NULL, @dh_priv2);
--error ER_UDF_ERROR
SELECT asymmetric_derive(42, @dh_priv2);
--error ER_UDF_ERROR
SELECT asymmetric_derive('blah-blah', @dh_priv2);

--error ER_UDF_ERROR
SELECT asymmetric_derive(@dh_pub1, NULL);
--error ER_UDF_ERROR
SELECT asymmetric_derive(@dh_pub1, 42);
--error ER_UDF_ERROR
SELECT asymmetric_derive(@dh_pub1, 'blah-blah');

--error ER_UDF_ERROR
SELECT asymmetric_derive(@dh_pub1, @dh_pub2);
--error ER_UDF_ERROR
SELECT asymmetric_derive(@dh_priv1, @dh_priv2);

SET @shared1 = asymmetric_derive(@dh_pub1, @dh_priv2);
SET @shared2 = asymmetric_derive(@dh_pub2, @dh_priv1);

--let $assert_text = DH shared keys generated by different parties must match
--let $assert_cond = @shared1 = @shared2
--source include/assert.inc

#
# Dropping functions from encryption_udf
#
DROP FUNCTION asymmetric_derive;
DROP FUNCTION create_dh_parameters;
DROP FUNCTION asymmetric_verify;
DROP FUNCTION asymmetric_sign;
DROP FUNCTION asymmetric_decrypt;
DROP FUNCTION asymmetric_encrypt;
DROP FUNCTION create_asymmetric_pub_key;
DROP FUNCTION create_asymmetric_priv_key;
DROP FUNCTION create_digest;
