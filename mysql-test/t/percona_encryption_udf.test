--source include/have_udf.inc

#
# Creating functions from encryption_udf
#
SET @algorithm = 'RSA';
SET @message = 'message';


--echo
--echo ** checking 'create_asymmetric_priv_key()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION create_asymmetric_priv_key RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

--error ER_CANT_INITIALIZE_UDF
SELECT create_asymmetric_priv_key();

--error ER_CANT_INITIALIZE_UDF
SELECT create_asymmetric_priv_key(@algorithm);

--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key(@algorithm, NULL);
--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key(@algorithm, 0);
--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key(@algorithm, -1);
--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key(@algorithm, 'blah');

--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key(@algorithm, 1023);

--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key(@algorithm, 16385);


--echo
--echo ** checking 'create_asymmetric_pub_key()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION create_asymmetric_pub_key RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

--error ER_CANT_INITIALIZE_UDF
SELECT create_asymmetric_pub_key();

--error ER_CANT_INITIALIZE_UDF
SELECT create_asymmetric_pub_key(@algorithm);

--error ER_UDF_ERROR
SELECT create_asymmetric_pub_key(@algorithm, NULL);
--error ER_UDF_ERROR
SELECT create_asymmetric_pub_key(@algorithm, 42);
--error ER_UDF_ERROR
SELECT create_asymmetric_pub_key(@algorithm, 'blah-blah');

--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key('FOO', 2048);


--echo
--echo ** checking 'asymmetric_encrypt()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION asymmetric_encrypt RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_encrypt();

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_encrypt(@algorithm);

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_encrypt(@algorithm, @message);

--error ER_UDF_ERROR
SELECT asymmetric_encrypt(@algorithm, @message, NULL);
--error ER_UDF_ERROR
SELECT asymmetric_encrypt(@algorithm, @message, 42);
--error ER_UDF_ERROR
SELECT asymmetric_encrypt(@algorithm, @message, 'blah-blah');

--error ER_UDF_ERROR
SELECT asymmetric_encrypt(@algorithm, NULL, NULL);


--echo
--echo ** checking 'asymmetric_decrypt()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION asymmetric_decrypt RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_decrypt();

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_decrypt(@algorithm);

--error ER_CANT_INITIALIZE_UDF
SELECT asymmetric_decrypt(@algorithm, @message);

--error ER_UDF_ERROR
SELECT asymmetric_decrypt(@algorithm, @message, NULL);
--error ER_UDF_ERROR
SELECT asymmetric_decrypt(@algorithm, @message, 42);
--error ER_UDF_ERROR
SELECT asymmetric_decrypt(@algorithm, @message, 'blah-blah');

--error ER_UDF_ERROR
SELECT asymmetric_decrypt(@algorithm, NULL, NULL);


--echo
--echo ** checking private key generation, public key derivation and encryption/decryption functionality
--let $key_length_index = 1
while ($key_length_index <= 3)
{
  --let $key_length = `SELECT ELT($key_length_index, 1024, 4096, 16384)`
  --echo **** generating $key_length - bit private key
  eval SET @rsa_priv = create_asymmetric_priv_key(@algorithm, $key_length);
  --echo **** deriving $key_length - bit public key
  SET @rsa_pub = create_asymmetric_pub_key(@algorithm, @rsa_priv);

  # <max message size> = <key length in bytes> - <pkcs1 padding>
  --let $max_message_size = `SELECT $key_length DIV 8 - 11`

  # size of MD5 hash in bytes is 32
  eval SET @random_pattern = REPEAT(MD5(42), $max_message_size DIV 32 + 1);

  --echo **** checking operations on NULL message
  SET @message = NULL;
  --echo ****** checking encryption of NULL message with public key
  --error ER_UDF_ERROR
  SELECT asymmetric_encrypt(@algorithm, @message, @rsa_pub);
  --echo ****** checking encryption of NULL message with private key
  --error ER_UDF_ERROR
  SELECT asymmetric_encrypt(@algorithm, @message, @rsa_priv);

  --let $message_index = 1
  while ($message_index <= 4)
  {
    --let $message_length = `SELECT ELT($message_index, 0, 1, $max_message_size DIV 2, $max_message_size)`
    eval SET @message = LEFT(@random_pattern, $message_length);
    --echo **** checking operations on $message_length - byte(s) message

    --echo ****** checking encryption of $message_length - byte(s) message with public key
    SET @message_enc_with_rsa_pub = asymmetric_encrypt(@algorithm, @message, @rsa_pub);
    --echo ****** checking decryption of $message_length - byte(s) message with private key
    SET @message_dec_with_rsa_priv = asymmetric_decrypt(@algorithm, @message_enc_with_rsa_pub, @rsa_priv);
    --let $assert_text = message of length $message_length - byte(s) decrypted with private key must match the original one
    --let $assert_cond = @message_dec_with_rsa_priv = @message
    --source include/assert.inc

    --echo ****** checking encryption of $message_length - byte(s) message with private key
    SET @message_enc_with_rsa_priv = asymmetric_encrypt(@algorithm, @message, @rsa_priv);
    --echo ****** checking decryption of $message_length - byte(s) message with public key
    SET @message_dec_with_rsa_pub = asymmetric_decrypt(@algorithm, @message_enc_with_rsa_priv, @rsa_pub);
    --let $assert_text = message of length $message_length - byte(s) decrypted with public key must match the original one
    --let $assert_cond = @message_dec_with_rsa_pub = @message
    --source include/assert.inc

    --inc $message_index
  }
  --let $message_length = $max_message_size + 1
  --echo **** checking operations on oversize message
  eval SET @message = LEFT(@random_pattern, $message_length);
  --echo ****** checking encryption of oversize message with public key
  --error ER_UDF_ERROR
  SELECT asymmetric_encrypt(@algorithm, @message, @rsa_pub);
  --echo ****** checking encryption of oversize message with private key
  --error ER_UDF_ERROR
  SELECT asymmetric_encrypt(@algorithm, @message, @rsa_priv);

  --inc $key_length_index
}


# not implemented yet
--error ER_UDF_ERROR
SELECT create_asymmetric_priv_key('DSA', 2048);

SET @digest_type = 'SHA224';
SET @message = 'message';

--echo
--echo ** checking 'create_digest()' function basics
--replace_result $ENCRYPTION_UDF_LIB ENCRYPTION_UDF_LIB
eval CREATE FUNCTION create_digest RETURNS STRING SONAME "$ENCRYPTION_UDF_LIB";

--error ER_CANT_INITIALIZE_UDF
SELECT create_digest();

--error ER_CANT_INITIALIZE_UDF
SELECT create_digest(@algorithm);

--error ER_UDF_ERROR
SELECT create_digest(@algorithm, NULL);

--error ER_UDF_ERROR
SELECT create_digest('FOO', @message);

--let $number_of_length_iterations = 16
--let $length_increment = 7
eval SET @random_pattern = REPEAT(MD5(42), $number_of_length_iterations * $length_increment DIV 32 + 1);

--echo ** checking digests calculation

CREATE TEMPORARY TABLE digest_type(
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  udf_template VARCHAR(64) NOT NULL,
  builtin_template VARCHAR(64),
  PRIMARY KEY(id)
);
INSERT INTO digest_type(udf_template, builtin_template) VALUES
  ('HEX(create_digest("MD5"   , @message))', 'MD5(@message)'),
  ('HEX(create_digest("SHA1"  , @message))', 'SHA(@message)'),

  ('HEX(create_digest("SHA224", @message))', 'SHA2(@message, 224)'),
  ('HEX(create_digest("SHA256", @message))', 'SHA2(@message, 256)'),
  ('HEX(create_digest("SHA384", @message))', 'SHA2(@message, 384)'),
  ('HEX(create_digest("SHA512", @message))', 'SHA2(@message, 512)'),

  ('HEX(create_digest("BLAKE2B512", @message))', NULL),
  ('HEX(create_digest("BLAKE2S256", @message))', NULL),
  ('HEX(create_digest("MD4"       , @message))', NULL),
  ('HEX(create_digest("RIPEMD"    , @message))', NULL),
  ('HEX(create_digest("RIPEMD160" , @message))', NULL),
  ('HEX(create_digest("RMD160"    , @message))', NULL),
  ('HEX(create_digest("SHAKE128"  , @message))', NULL),
  ('HEX(create_digest("SHAKE256"  , @message))', NULL),
  ('HEX(create_digest("SM3"       , @message))', NULL),
  ('HEX(create_digest("WHIRLPOOL" , @message))', NULL)
;
--let $number_of_digest_types = `SELECT COUNT(*) FROM digest_type`

--let $digest_type_idx = 1
while($digest_type_idx <= $number_of_digest_types)
{
  --let $udf_template = `SELECT udf_template FROM digest_type WHERE id = $digest_type_idx`
  --echo **** checking $udf_template digest

  --let $builtin_template = `SELECT builtin_template FROM digest_type WHERE id = $digest_type_idx`
  --let $current_length_iteration = 0
  --let $number_of_length_iterations = 16
  while($current_length_iteration <= $number_of_length_iterations)
  {
    --let $message_length = `SELECT $current_length_iteration * $length_increment`
    --echo ****** checking digest calculation on $message_length - byte(s) message
    eval SET @message = LEFT(@random_pattern, $message_length);

    if($builtin_template)
    {
      --let $assert_text = digest of a message of length $message_length - byte(s) calculated via UDF should match built-in function result
      --let $assert_cond = $udf_template = $builtin_template
    }
    if(!$builtin_template)
    {
      --let $assert_text = digest of a message of length $message_length - byte(s) calculated via UDF is not NULL
      --let $assert_cond = $udf_template IS NOT NULL
    }
    --source include/assert.inc

    --inc $current_length_iteration
  }

  --inc $digest_type_idx
}

#
# Dropping functions from encryption_udf
#
DROP FUNCTION create_digest;
DROP FUNCTION asymmetric_decrypt;
DROP FUNCTION asymmetric_encrypt;
DROP FUNCTION create_asymmetric_pub_key;
DROP FUNCTION create_asymmetric_priv_key;
